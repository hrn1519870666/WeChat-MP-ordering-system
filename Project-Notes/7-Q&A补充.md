#### 除了分布式锁之外，解决超卖问题的方法

1. 在sql上加判断，防止数据变为负数。 
2. Redis预减库存：系统初始化的时候，将商品库存加载到Redis 缓存中保存。收到请求的时候,先在Redis中拿到该商品的库存值，进行库存预减，如果减完之后库存不足，直接抛异常，不需要访问数据库，如果库存值正确，则执行秒杀逻辑。



#### Redis的库存如何与数据库的库存保持一致

Redis的数量不是库存,他的作用仅仅只是为了阻挡多余的请求透穿到DB，起到一个保护的作用，不需要保持一致。



#### Redis 分布式锁的实现方法

我用了四种方法 ，不同版本的缺陷以及演进的过程如下：

1. 没有操作，在并发场景中容易出现问题。
2. 加synchronized锁
3. 加Redis分布式锁，在访问核心方法前，加入Redis锁可以阻塞其他线程访问,可以很好的处理并发问题,但是缺陷是如果机器突然宕机，就会造成死锁问题。
4. 加入时间对比，如果当前时间>释放锁的时间，说明已经可以释放这个锁重新再获取锁，getset方法可以把之前的锁去掉再重新获取，旧值与之前的值比较，如果无变化说明这个期间没有人获取或者操作这个Redis锁，可以重新获取。



#### 整体设计

说一下你这个商城项目运作的流程？（从用户角度和开发者角度解答，在每步中所用到的技术）

挑一个模块说一下你是怎么实现的？

下单过程是如何设计的？

如果有用户反馈说整个系统的反馈比较慢，你是如何排查和如何解决问题的？



#### 数据库

商城的数据库表结构是怎样设计的？（分不同服务的表进行解答）

表上加索引了吗？

详细介绍一下订单表的结构？



**下订单的sql语句如何编写的？（考察MySQL的乐观锁）**

用JPA+@Transactional注解实现。



#### Redis

如果业务还没执行完，锁到期了怎么办？

Redis与数据库同步的时候出现问题是如何解决的？



#### 细节问题

**用户购买商品时，什么时候才减少库存？**

提交订单，支付状态由未付款改成支付成功后，才会减少库存。（代码是在创建订单时扣库存，这样做不对）

**项目的金额用什么数据类型存储？**

使用BigDecimal来表示金额，数据库选择decimal类型, 长度可以自定义, 小数在项目中用的是2, 保留2位小数。



#### 其他问题

**使用的springboot版本？**

v1.5.3.RELEASE

**你有没有压测过？能同时接受最多多少人下单？**



**部署过程中是否有使用什么参数、指令？**











#### 数据库表

重要字段如下

类目表：category_id，category_type

商品详情表：product_id，category_id，product_status，product_stock

订单主表：order_id，buyer_openid，order_status，pay_status

订单详情表：detail_id，order_id，product_id

卖家表：openid

**类目表和商品详情表，通过category_id关联。**

**订单主表和订单详情表，通过order_id关联，一笔订单可能有多个商品。**

**订单详情表和商品详情表，通过product_id关联。**



#### Dao层

使用Spring Data JPA 对数据库操作。



#### Service层

**OrderServiceImpl：**

创建订单、取消订单、完结订单、付款方法需要加@Transactional注解，表示该方法需要事务管理，防止突然出现异常(宕机、断电)。我们希望这些方法要么全部执行成功，要么全部失败。

orderId是String类型主键，需要随机生成一个字符串来确保主键唯一，为了防止多线程异步导致订单号重复，还要使用synchronized。

**ProductServiceImpl：**加库存、减库存方法也要加@Transactional注解。